<!doctype html><html lang="en"><head><meta charset="utf-8"><meta content="width=device-width,initial-scale=1" name="viewport"><title>Aula 3 - Memórias cache, interna e externa, aula 1</title><style>a,abbr,acronym,address,applet,article,aside,audio,b,big,blockquote,body,canvas,caption,center,cite,code,dd,del,details,dfn,div,dl,dt,em,embed,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,header,hgroup,html,i,iframe,img,ins,kbd,label,legend,li,mark,menu,nav,object,ol,output,p,pre,q,ruby,s,samp,section,small,span,strike,strong,sub,summary,sup,table,tbody,td,tfoot,th,thead,time,tr,tt,u,ul,var,video{margin:0;padding:0;border:0;font-size:100%;font:inherit;vertical-align:baseline}article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section{display:block}body{line-height:1}blockquote,q{quotes:none}blockquote:after,blockquote:before,q:after,q:before{content:'';content:none}table{border-collapse:collapse;border-spacing:0}</style><style>:root{--main-bg:#282828;--main-fg:#ebdbb2;--main-fg-20:#ebdbb266;--main-fg-40:#ebdbb2dd;--main-primary:#fe8019;--main-primary-20:#fe801966}body{font-family:-apple-system,BlinkMacSystemFont,avenir next,avenir,segoe ui,helvetica neue,Adwaita Sans,Cantarell,Ubuntu,roboto,noto,helvetica,arial,sans-serif;min-height:100vh;display:flex;justify-content:center;background-color:var(--main-bg);color:var(--main-fg);line-height:1.35}.content{width:100%;max-width:960px;margin:2rem 1rem}.title{font-size:2.986rem;color:var(--main-primary);font-weight:700}.subtitle{font-size:1.2rem;margin-bottom:.5rem;opacity:.5}.subtitle-2{font-size:1.44rem;margin-top:2rem;margin-bottom:.5rem;font-weight:700}.class-date{opacity:.35}a,a:visited{color:var(--main-fg);text-decoration:none}a:hover{text-decoration:underline}ol,ul{margin-left:1rem}ol+p,ul+p{margin-top:1rem}li{margin-bottom:.5rem}li::marker{opacity:.6}</style><style>.md h1{font-size:2.986rem;color:var(--main-primary);font-weight:700}.md h2{font-size:2.074rem;margin:.8em 0 .4em 0;border-bottom:2px solid var(--main-primary-20)}.md h3{display:inline-block;font-size:1.44rem;margin-bottom:.2em;border-bottom:2px solid var(--main-fg-20)}.md .subtitle{margin-bottom:2rem}.md a,.md a:visited{text-decoration:underline;text-decoration-color:var(--main-fg-20)}.md .mermaid{display:flex;justify-content:center;margin-bottom:1rem}.md .mermaid svg{background-color:var(--main-fg-40)}.md table,.md td,.md th{border:1px solid var(--main-fg-20)}.md td,.md th{padding:.1rem .2rem}.md th{font-weight:700}.md p{margin-bottom:1rem}.md table{margin:0 auto 1rem auto}.md em{font-style:italic}.md strong{font-weight:700}</style></head><body><div class="content md"><h1>Aula 3 - Memórias cache, interna e externa, aula 1</h1><p class="subtitle">25/08/2025</p><p>A memória do computador é organizada de forma hierárquica. No nível mais perto do processador estão os registradores. Em seguida, vem um ou mais níveis de cache, indicados por L1, L2, e assim por diante. Após, vem a memória principal, que normalmente é de acesso aleatório e dinâmico (RAM). Esses níveis de memória são considerados internos ao computador. Existem também níveis hierárquicos de memória externa, com o próximo nível sendo um ou mais discos rígidos fixos (HD ou SSD), e por último as mídias removíveis (CD, Pen-drive, etc).</p><p>À medida que descemos na hierarquia de memória, o custo por bit diminui, o que permite uma maior capacidade de armazenamento. Em contrapartida, o tempo de acesso também aumenta conforme avançamos na hierarquia. Em um mundo ideal, apenas memórias mais rápidas são utilizadas, mas por conta do alto custo, as hierarquias existem para baratear o projeto. O desafio então se torna organizar os dados e os programas na memória de modo que os blocos de memória acessados com mais frequência estejam nas memórias mais rápidas possíveis.</p><p>Em geral, existe uma maior probabilidade que a maioria dos acessos futuros à memória principal, feitos pelo processador, sejam para blocos de memória acessados recentemente. Assim, a <em>cache</em> mantém automaticamente uma cópia de alguns dos blocos de memória usados recentemente. Se o <em>cache</em> for projetado corretamente, na maior parte do tempo o processador solicitará palavras da memória que já estão no <em>cache</em>.</p><h2>Características dos sistemas de memória</h2><p>A seguir estão as principais características dos sistemas de memória:</p><ul><li>Localização:<ul><li>interna: registradores, <em>cache</em>, RAM</li><li>externa: HD, SSD, mídias removíveis, etc</li></ul></li><li>Capacidade: para a memória interna, é normalmente expressa em <em>bytes</em> ou palavras. Para a memória externa, é normalmente expressa em <em>bytes</em>.<ul><li>a palavra é a unidade "natural" de organização de memória. É uma sequência de tamanho fixo que a CPU processa em conjunto.</li></ul></li><li>Método de acesso:<ul><li>acesso sequencial: a memória é organizada em unidades de dados chamados registros. O acesso é feito em uma sequência linear específica. As unidades de fita são de acesso sequencial.</li><li>acesso direto: similar ao acesso sequencial, mas os blocos individuais tem um endereço exclusivo, baseado no local físico. As unidades de disco magnético são de acesso direto.</li><li>acesso aleatório: cada local da memória tem um mecanismo de endereçamento exclusivo, e qualquer local pode ser acessado diretamente de forma aleatória. A memória principal, alguns sistemas cache e os SSD são de acesso aleatório.</li><li>acesso associativo: permite acessar memória não por endereço, mas por um número de bits desejados em uma palavra, permitindo o acesso com base em uma parte do conteúdo ao invés do endereço de memória. As memórias cache podem usar esse método de acesso.</li></ul></li><li>Parâmetros de desempenho:<ul><li>tempo de acesso (latência): tempo gasto desde o instante que um endereço é solicitado até o instante que os dados foram salvos ou retornados da memória.</li><li>tempo de ciclo de memória: tempo de acesso mais qualquer tempo adicional antes que um próximo acesso possa iniciar.</li></ul></li><li>Volatilidade:<ul><li>volátil: a informação se perde quando a energia elétrica é desligada</li><li>não volátil: nenhuma energia elétrica é necessária para manter a informação</li></ul></li></ul><h2>Hierarquia de memória</h2><p>Como citado anteriormente, empregar uma hierarquia de memória pode ajudar a equilibrar o custo monetário de um projeto computacional.</p><p>Uma hierarquia comum é composta por:</p><ol><li>Registradores</li><li>Memória cache</li><li>Memória principal</li><li>Memória secundária</li><li>Memória em mídia removível</li></ol><p>Enquanto se desce na hierarquia, ocorre normalmente o seguinte:</p><ol><li>Diminui o custo por bit</li><li>Aumenta a capacidade em bits</li><li>Aumenta o tempo de acesso da memória</li><li>Diminui a frequência de acesso a esta memória pelo computador</li></ol><h2>Princípios da memória cache</h2><p>O uso da memória cache visa encontrar um meio-termo, obtendo velocidades mais próximas das memórias mais rápidas e, ao mesmo tempo, disponibilizar uma capacidade ao preço de memórias mais baratas.</p><p>O cache contém uma cópia de partes da memória principal. Quando o processador tenta ler uma palavra da memória, primeiro verifica-se se a palavra já está no cache. Se estiver, ela já é entregue ao processador. Se não, um bloco da memória principal, consistindo em um número fixo de palavras, é lido para o cache e depois a palavra é fornecida ao processador. Quando um bloco de dados é levado para o cache por conta de uma única referência de memória, é provável haver referências futuras a esse mesmo local ou a outras palavras no mesmo bloco, e isto se chama fenômeno de <strong>localidade de referência</strong>.</p><pre class="mermaid">  %%{init: {'theme':'forest'}}%%
  flowchart LR
    CPU[CPU] &lt;-- Transferência\nde palavra\n&lt;em>&#40rápida&#41&lt;/em> --> MC[Memória cache]
    MC &lt;-- Transferência\n de bloco\n&lt;em>&#40lenta&#41&lt;/em> --> MP[Memória principal]
</pre><h2>Algoritmos de substituição</h2><p>Uma vez que o cache estiver cheio e um novo bloco precisar ser trazido, um dos blocos existentes precisa ser substituído. Existem vários algoritmos de substituição na literatura, e os quatro mais comuns são:</p><ul><li>LRU (<em>least recently used</em>): substituir o bloco que foi usado por último</li><li>FIFO (<em>first-in-first-out</em>): substituir o bloco que esteve no cache por mais tempo</li><li>LFU (<em>least frequently used</em>): substituir o bloco usado menos vezes até agora</li><li>Aleatório: substituir uma linha aleatória do <em>cache</em></li></ul><h2>Política de escrita</h2><p>Quando um bloco estiver para ser substituído do <em>cache</em>, existem dois casos a se considerar: se o bloco não tiver sido alterado, ele pode ser substituído sem problemas. Se pelo menos uma operação de escrita tiver sido realizada em uma palavra desse bloco no <em>cache</em>, é necessário atualizar a memória principal com o novo valor. Existem diversas políticas de escrita na RAM para essas alterações, sendo os principais:</p><ul><li><em>write-through</em>: todas as operações de escrita são feitas na memória principal e também na memória cache, garantindo que os dados sejam sempre válidos. A principal desvantagem é que ela gera um tráfego de memória que pode se tornar um gargalo de performance.</li><li><em>write-back</em>: as atualizações são feitas apenas no <em>cache</em>, e só são refletidas na memória principal antes da substituição daquele bloco. A principal desvantagem é que essa técnica pode invalidar partes da memória principal, já que aquela memória pode ter sido atualizada por outra parte do sistema, por exemplo, por um módulo de E/S.</li></ul><script async type="module">import mermaid from"https://unpkg.com/mermaid@10/dist/mermaid.esm.min.mjs";document.addEventListener("DOMContentLoaded",mermaid.initialize({loadOnSave:!0}))</script></div></body></html>