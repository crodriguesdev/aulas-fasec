<!doctype html><html lang="en"><head><meta charset="utf-8"><meta content="width=device-width,initial-scale=1" name="viewport"><title>Aula 4 - Memórias cache, interna e externa, aula 2</title><style>a,abbr,acronym,address,applet,article,aside,audio,b,big,blockquote,body,canvas,caption,center,cite,code,dd,del,details,dfn,div,dl,dt,em,embed,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,header,hgroup,html,i,iframe,img,ins,kbd,label,legend,li,mark,menu,nav,object,ol,output,p,pre,q,ruby,s,samp,section,small,span,strike,strong,sub,summary,sup,table,tbody,td,tfoot,th,thead,time,tr,tt,u,ul,var,video{margin:0;padding:0;border:0;font-size:100%;font:inherit;vertical-align:baseline}article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section{display:block}body{line-height:1}blockquote,q{quotes:none}blockquote:after,blockquote:before,q:after,q:before{content:'';content:none}table{border-collapse:collapse;border-spacing:0}</style><style>:root{--main-bg:#282828;--main-fg:#ebdbb2;--main-fg-20:#ebdbb266;--main-fg-40:#ebdbb2dd;--main-primary:#fe8019;--main-primary-20:#fe801966}body{font-family:-apple-system,BlinkMacSystemFont,avenir next,avenir,segoe ui,helvetica neue,Adwaita Sans,Cantarell,Ubuntu,roboto,noto,helvetica,arial,sans-serif;min-height:100vh;display:flex;justify-content:center;background-color:var(--main-bg);color:var(--main-fg);line-height:1.35;padding:2rem 1rem}.content{width:100%;max-width:960px}.title{font-size:2.986rem;color:var(--main-primary);font-weight:700}.subtitle{font-size:1.2rem;margin-bottom:.5rem;opacity:.5}.subtitle-2{font-size:1.44rem;margin-top:2rem;margin-bottom:.5rem;font-weight:700}.class-date{opacity:.35}a,a:visited{color:var(--main-fg);text-decoration:none}a:hover{text-decoration:underline}ol,ul{margin-left:1rem}ol+p,ul+p{margin-top:1rem}li{margin-bottom:.5rem}li::marker{opacity:.6}</style><style>.md h1{font-size:2.986rem;color:var(--main-primary);font-weight:700}.md h2{font-size:2.074rem;margin:.8em 0 .4em 0;border-bottom:2px solid var(--main-primary-20)}.md h3{display:inline-block;font-size:1.44rem;margin-bottom:.2em;border-bottom:2px solid var(--main-fg-20)}.md .subtitle{margin-bottom:2rem}.md a,.md a:visited{text-decoration:underline;text-decoration-color:var(--main-fg-20)}.md .mermaid{display:flex;justify-content:center;margin-bottom:1rem;border:none}.md .mermaid svg{background-color:var(--main-fg-40)}.md table,.md td,.md th{border:1px solid var(--main-fg-20)}.md td,.md th{padding:.1rem .2rem}.md th{font-weight:700}.md p{margin-bottom:1rem}.md table{margin:0 auto 1rem auto}.md em{font-style:italic}.md strong{font-weight:700}.md pre{padding:.1rem .2rem;border:1px solid var(--main-fg-20);font-family:Consolas,Monaco,"Andale Mono","Ubuntu Mono",monospace}.md img{max-width:100%;margin:1rem auto;display:block;padding:1rem;background-color:var(--main-fg-20)}.md .mono{font-family:Consolas,Monaco,"Andale Mono","Ubuntu Mono",monospace}</style><style>code[class*=language-],pre[class*=language-]{color:#ebdbb2;font-family:Consolas,Monaco,"Andale Mono",monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}code[class*=language-] ::-moz-selection,code[class*=language-]::-moz-selection,pre[class*=language-] ::-moz-selection,pre[class*=language-]::-moz-selection{color:#fbf1c7;background:#7c6f64}code[class*=language-] ::selection,code[class*=language-]::selection,pre[class*=language-] ::selection,pre[class*=language-]::selection{color:#fbf1c7;background:#7c6f64}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}:not(pre)>code[class*=language-],pre[class*=language-]{background:#1d2021}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em}.token.cdata,.token.comment,.token.prolog{color:#a89984}.token.atrule,.token.boolean,.token.delimiter,.token.important,.token.keyword,.token.selector{color:#fb4934}.token.attr-name,.token.operator,.token.punctuation{color:#a89984}.token.builtin,.token.doctype,.token.tag,.token.tag .punctuation{color:#fabd2f}.token.entity,.token.number,.token.symbol{color:#d3869b}.token.constant,.token.property,.token.variable{color:#fb4934}.token.char,.token.string{color:#b8bb26}.token.attr-value,.token.attr-value .punctuation{color:#a89984}.token.url{color:#b8bb26;text-decoration:underline}.token.function{color:#fabd2f}.token.regex{background:#b8bb26}.token.bold{font-weight:700}.token.italic{font-style:italic}.token.inserted{background:#a89984}.token.deleted{background:#fb4934}</style></head><body><div class="content md"><h1>Aula 4 - Memórias cache, interna e externa, aula 2</h1><p class="subtitle">01/09/2025</p><h2>Memória interna</h2><p>Nos primeiros computadores, a forma mais comum de armazenamento de acesso aleatório para a memória principal utilizava uma matriz de anéis ferromagnéticos, chamados de núcleo. Com a evolução da eletrônica, atualmente as memórias em chips semicondutores são utilizadas, superando a performance dos loops ferromagnéticos.</p><p>O elemento básico de uma memória semicondutora é a célula de memória. Embora diversas tecnologias eletrônicas sejam utilizadas, todas as células de memória semicondutora possuem pelo menos as seguintes propriedades:</p><ul><li>apresentam dois estados estáveis (ou semi estáveis), que podem ser usados para representar o binário 1 e 0</li><li>são capazes de ser escritas pelo menos uma vez</li><li>são capazes de ser lidas conforme a necessidade</li></ul><p>Normalmente a célula de memória tem três terminais eletrônicos:</p><ul><li>terminal de seleção: é o "endereço", e seleciona a célula para a operação de leitura ou escrita</li><li>terminal de controle: indica a operação, se é leitura ou escrita</li><li>terminal de estado: entrega o estado atual do terminal de memória (leitura) ou recebe um sinal de entrada e define o estado da célula</li></ul><p>Memórias de acesso aleatório permitem acessar diretamente blocos de memória através de lógicas de endereçamento. Existem diversas memórias de acesso aleatório feitas com semicondutor, sendo as principais:</p><table><tr><th>Tipo de memória</th><th>Categoria</th><th>Apagamento</th><th>Mecanismo de escrita</th><th>Volatilidade</th></tr><tr><td>Memória de acesso aleatório (RAM)</td><td>Memória de leitura-escrita</td><td>Eletricamente, a nível de byte</td><td>Eletricamente</td><td>Volátil</td></tr><tr><td>Memória somente de leitura (ROM)</td><td rowspan="2">Memória somente de leitura</td><td rowspan="2">Não é possível</td><td>Máscaras</td><td rowspan="5">Não volátil</td></tr><tr><td>ROM programável (PROM)</td><td rowspan="4">Eletricamente</td></tr><tr><td>PROM apagável (EPROM)</td><td rowspan="3">Memória principalmente de leitura</td><td>Luz UV, nível de chip</td></tr><tr><td>PROM eletricamente apagável (EEPROM)</td><td>Eletricamente, nível de byte</td></tr><tr><td>Memória flash</td><td>Eletricamente, nível de bloco</td></tr></table><p>As duas formas básicas de memória de acesso aleatório são a RAM dinâmica (DRAM) e a RAM estática (SRAM). A SRAM é mais rápida, cara e menos densa que a DRAM, e é mais usada em memórias cache. A DRAM é mais barata, lenta, e mais usada na memória principal.</p><p>A RAM dinâmica é feita com células que guardam os dados como carga em capacitores. A presença ou ausência de carga neste capacitor indica o binário 1 ou 0. Como os capacitores possuem uma tendência natural para a descarga, essas memórias exigem recarga periódica ("refresh" de memória) para manter o dado armazenado. O termo <em>dinâmica</em> refere-se a essa tendência de perda da carga armazenada, mesmo com energia aplicada continuamente.</p><p>Uma RAM estática é um dispositivo que utiliza flip-flops tradicionais para armazenar dados, e ela irá manter esses dados enquanto houver energia fornecida a ela.</p><p>Tanto uma memória SRAM quanto uma memória DRAM são voláteis, ou seja, precisam ser mantidas ligadas à energia para preservar seus valores. Uma célula de memória dinâmica é mais simples e menor do que uma célula de memória estática, permitindo chips menores que armazenam a mesma quantidade de <em>bytes</em>. Em compensação, a DRAM requer um circuito de <em>refresh</em>.</p><h3>Memórias ROM</h3><p>Uma memória somente leitura (ROM) contém um padrão permanente de dados, que não pode ser mudado. Uma memória ROM não é volátil. Embora seja possível ler uma ROM, não é possível escrever algo novo nela. Aplicações das ROM estão na eletrônica e na microprogramação. Sua principal vantagem é que os dados estão presentes de forma permanente na memória, e nunca precisam ser carregados novamente de um armazenamento secundário.</p><h3>Correção de erro</h3><p>Um sistema de memória semicondutora está sujeita a erros. Esses podem ser categorizados como permanentes e não permanentes. Uma falha permanente é um defeito físico no circuito, de modo que uma ou mais células de memória afetadas não podem armazenar dados de modo confiável. Os erros permanentes podem ser causados por uso intenso em ambiente impróprio, defeitos de fabricação ou desgaste. Um erro não permanente é um evento aleatório, nào destrutivo, que altera o conteúdo de uma ou mais células de memória sem danificá-la. Esses erros podem ser causados por oscilações na fonte de alimentação ou partículas alfa. Essas partículas são resultado de um declínio radioativo, e são muito comuns, pois átomos radioativos são encontrados em pequenas quantidades em quase todos os materiais. A maioria dos sistemas de memória modernos possui alguma lógica para detectar e corrigir esses erros indesejáveis, sendo o mais comum a utilização de bits de paridade.</p><h2>Memória externa</h2><p>A memória externa é responsável por armazenar dados de forma não volátil e permanente. No geral são utilizados discos magnéticos (HDs) ou memória flash (SSDs).</p><h3>RAID</h3><p>É possível utilizar vários discos para organizar-se os dados, melhorando performance e confiabilidade. O padrão RAID foi normalizado pela indústria, e consiste em sete níveis, de zero a seis. Esses níveis não implicam um relacionamento hierárquico, mas designam diferentes arquiteturas de projeto, que compartilham três características em comum:</p><ul><li><p>RAID é um conjunto de discos fisicos (array) vistos pelo sistema operacional como um único disco lógico</p></li><li><p>Os dados são distribuídos pelos discos físicos de um array em um esquema conhecido como intercalação de dados</p></li><li><p>A capacidade de disco redundante é usada para armazenar informações de paridade</p></li><li><p>RAID 0: não é um membro verdadeiro da família RAID, pois não inclui redundância. Nesse nível, os dados de usuário e do sistema são distribuídos por todos os discos do array, intercalados pelos discos disponíveis</p></li><li><p>RAID 1: difere dos níveis de 2 a 6 no modo como a redundância é obtida. Nesse esquema, a redundância é obtida pelo simples ato de duplicar todos os dados. A principal desvantagem do RAID 1 é o custo, pois é necessário o dobro de espaço em disco do que a capacidade lógica disponível para o usuário e sistema</p></li><li><p>RAID 2: divide os dados, como o RAID 0, mas mantém códigos de correção de erros em discos específicos. Todos os discos membros participam de cada solicitação de E/S, e normalmente os eixos individuais são sincronizados.</p></li><li><p>RAID 3: idêntico ao RAID 2, mas utilizando apenas um único disco redundante, não importa o tamanho do array de discos. Ao invés de um código de correção de erro, um bit de paridade simples é calculado para o conjunto de bits individuais na mesma posição em todos os discos</p></li><li><p>RAID 4: utiliza uma técnica de acesso independente. Cada disco membro opera independentemente, de modo que as solicitações de E/S podem ser satisfeitas em paralelo. Calcula e armazena a paridade de um bloco inteiro em um disco de paridade</p></li><li><p>RAID 5: é organizado da mesma forma qoe o RAID 4, sendo a única diferença que este distribui os blocos de paridade por todos os discos</p></li><li><p>RAID 6: no esquema RAID 6, dois cálculos de paridade diferentes são executados e armazenados em blocos separados em discos diferentes. Ele oferece uma disponibilidade de dados extremamente alta.</p></li></ul><script async type="module">import mermaid from"https://unpkg.com/mermaid@10/dist/mermaid.esm.min.mjs";document.addEventListener("DOMContentLoaded",mermaid.initialize({loadOnSave:!0}))</script></div></body></html>