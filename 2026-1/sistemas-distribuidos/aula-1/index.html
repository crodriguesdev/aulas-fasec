<!doctype html><html lang="en"><head><meta charset="utf-8"><meta content="width=device-width,initial-scale=1" name="viewport"><title>Aula 1 - Conceitos Fundamentais de Sistemas Distribuídos</title><style>a,abbr,acronym,address,applet,article,aside,audio,b,big,blockquote,body,canvas,caption,center,cite,code,dd,del,details,dfn,div,dl,dt,em,embed,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,header,hgroup,html,i,iframe,img,ins,kbd,label,legend,li,mark,menu,nav,object,ol,output,p,pre,q,ruby,s,samp,section,small,span,strike,strong,sub,summary,sup,table,tbody,td,tfoot,th,thead,time,tr,tt,u,ul,var,video{margin:0;padding:0;border:0;font-size:100%;font:inherit;vertical-align:baseline}article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section{display:block}body{line-height:1}blockquote,q{quotes:none}blockquote:after,blockquote:before,q:after,q:before{content:'';content:none}table{border-collapse:collapse;border-spacing:0}</style><style>:root{--main-bg:#282828;--main-fg:#ebdbb2;--main-fg-20:#ebdbb266;--main-fg-40:#ebdbb2dd;--main-primary:#fe8019;--main-primary-20:#fe801966}body{font-family:-apple-system,BlinkMacSystemFont,avenir next,avenir,segoe ui,helvetica neue,Adwaita Sans,Cantarell,Ubuntu,roboto,noto,helvetica,arial,sans-serif;min-height:100vh;display:flex;justify-content:center;background-color:var(--main-bg);color:var(--main-fg);line-height:1.35;padding:2rem 1rem}.content{width:100%;max-width:960px}.title{font-size:2.986rem;color:var(--main-primary);font-weight:700}.subtitle{font-size:1.2rem;margin-bottom:.5rem;opacity:.5}.subtitle-2{font-size:1.44rem;margin-top:2rem;margin-bottom:.5rem;font-weight:700}.class-date{opacity:.35}a,a:visited{color:var(--main-fg);text-decoration:none}a:hover{text-decoration:underline}ol,ul{margin-left:1rem}ol+p,ul+p{margin-top:1rem}li{margin-bottom:.5rem}li::marker{opacity:.6}</style><style>.md h1{font-size:2.986rem;color:var(--main-primary);font-weight:700}.md h2{font-size:2.074rem;margin:.8em 0 .4em 0;border-bottom:2px solid var(--main-primary-20)}.md h3{display:inline-block;font-size:1.44rem;margin-bottom:.2em;border-bottom:2px solid var(--main-fg-20)}.md .subtitle{margin-bottom:2rem}.md a,.md a:visited{text-decoration:underline;text-decoration-color:var(--main-fg-20)}.md .mermaid{display:flex;justify-content:center;margin-bottom:1rem;border:none}.md .mermaid svg{background-color:var(--main-fg-40)}.md table,.md td,.md th{border:1px solid var(--main-fg-20)}.md td,.md th{padding:.1rem .2rem}.md th{font-weight:700}.md p{margin-bottom:1rem}.md table{margin:0 auto 1rem auto}.md em{font-style:italic}.md strong{font-weight:700}.md pre{padding:.1rem .2rem;border:1px solid var(--main-fg-20);font-family:Consolas,Monaco,"Andale Mono","Ubuntu Mono",monospace}.md img{max-width:100%;margin:1rem auto;display:block;padding:1rem;background-color:var(--main-fg-20)}.md .mono{font-family:Consolas,Monaco,"Andale Mono","Ubuntu Mono",monospace}</style><style>code[class*=language-],pre[class*=language-]{color:#ebdbb2;font-family:Consolas,Monaco,"Andale Mono",monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}code[class*=language-] ::-moz-selection,code[class*=language-]::-moz-selection,pre[class*=language-] ::-moz-selection,pre[class*=language-]::-moz-selection{color:#fbf1c7;background:#7c6f64}code[class*=language-] ::selection,code[class*=language-]::selection,pre[class*=language-] ::selection,pre[class*=language-]::selection{color:#fbf1c7;background:#7c6f64}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}:not(pre)>code[class*=language-],pre[class*=language-]{background:#1d2021}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em}.token.cdata,.token.comment,.token.prolog{color:#a89984}.token.atrule,.token.boolean,.token.delimiter,.token.important,.token.keyword,.token.selector{color:#fb4934}.token.attr-name,.token.operator,.token.punctuation{color:#a89984}.token.builtin,.token.doctype,.token.tag,.token.tag .punctuation{color:#fabd2f}.token.entity,.token.number,.token.symbol{color:#d3869b}.token.constant,.token.property,.token.variable{color:#fb4934}.token.char,.token.string{color:#b8bb26}.token.attr-value,.token.attr-value .punctuation{color:#a89984}.token.url{color:#b8bb26;text-decoration:underline}.token.function{color:#fabd2f}.token.regex{background:#b8bb26}.token.bold{font-weight:700}.token.italic{font-style:italic}.token.inserted{background:#a89984}.token.deleted{background:#fb4934}</style></head><body><div class="content md"><h1>Aula 1 - Conceitos Fundamentais de Sistemas Distribuídos</h1><p class="subtitle">13/02/2026</p><p>Um sistema distribuído é aquele no qual os componentes deste sistema se localizam em computadores interligados via rede. Esses componentes se comunicam e coordenam suas ações via trocas de mensagens. Os componentes conectados podem estar separados por qualquer distância. Eles podem estar em continentes separados, na mesma sala, ou até na mesma máquina.</p><p>Alguns exemplos de sistemas distribuídos incluem:</p><ul><li>a própria Internet;</li><li>uma intranet (rede interna de uma organização);</li><li>redes móveis de celulares;</li><li>jogos eletrônicos multijogador;</li><li>aplicativos de troca de mensagem, como WhatsApp.</li></ul><p>A própria definição já traz algumas consequências para o programador, entre elas:</p><ul><li>concorrência: ocorre quando múltiplos componentes executam tarefas simultâneas e precisam interagir entre si para se sincronizarem e atingir um objetivo em comum;</li><li>falta de relógio global: caso a coordenação dependa de uma noção do tempo que as ações aconteceram, a precisão do relógio de cada computador pode interferir no resultado;</li><li>falhas independentes: cada componente do sistema pode falhar de forma independente, deixando os outros ainda em funcionamento.</li></ul><h2>Desafios</h2><p>O compartilhamento de recursos e tolerância a falhas são fortes motivos para a construção e adoção de um sistema distribuído, mas os desafios desta arquitetura devem ser levados em consideração, como por exemplo a possível diferença entre componentes (linguagens de programação, versões de aplicações ou mesmo sistemas operacionais diferentes). Além do mais, um sistema distribuído pode ser um sistema aberto, isto é, novos componentes podem ser adicionados, removidos ou substituídos sem a necessidade de parar completamente a aplicação, o que traz ganhos de escalabilidade (funcionar bem mesmo quando a quantidade de usuários aumenta) e ao tratamento de falha de algum componente, mas também resulta em necessidades maiores de tratamentos de segurança e concorrência de componentes.</p><h3>Heterogeneidade</h3><p>Sistemas distribuídos permitem acessos a serviços e componentes por meio de um conjunto heterogêneo de computadores e redes. Alguns exemplos de aspectos que podem ser diferentes são:</p><ul><li>redes: as diferenças entre redes são normalmente mascaradas pelo fato de que todos os dispositivos ligados a elas utilizam algum protocolo Internet para se comunicar.</li><li>hardware: os dados podem ser representados de diversas maneiras em diferentes tipos de hardware, por exemplo a quantidade de bytes de um tipo de variável pode ser diferente entre hardwares ou sistemas diferentes. Essas diferenças devem ser consideradas em um sistema distribuído.</li><li>sistemas operacionais: embora os SO incluam funcionalidades parecidas, nem todas as oferecem da mesma forma para os aplicativos.</li><li>linguagens de programação: diferentes linguagens de programação usam diferentes representações para caracteres, estruturas de dados, objetos, entre outros. Essas diferenças precisam ser consideradas.</li></ul><p>Para que programas escritos por diferentes desenvolvedores para diferentes plataformas se comuniquem, alguns padrões devem ser estabelecidos e utilizados por todas as partes.</p><h3>Sistema aberto</h3><p>Um sistema computacional é aberto quando ele pode ser estendido e reimplementado de várias maneiras. Um sistema distribuído não necessariamente é um sistema aberto, e isso é determinado principalmente pelo grau com que novos serviços podem ser adicionados e disponibilizados para uso por uma variedade de programas clientes.</p><p>Um fator importante para um sistema aberto é que a especificação e documentação das principais interfaces de software dos componentes devem estar disponíveis para os desenvolvedores de software. Além do mais, o sistema deve ser desenvolvido permitindo o acoplamento de novas funcionalidades através destas interfaces.</p><p>Um grande desafio para um sistema distribuído aberto para extensões é a complexidade de sincronizar e coordenar muitos componentes elaborados de diferentes formas por diferentes pessoas.</p><p>Um exemplo de documentação de sistemas distribuídos abertos são as <a href="https://www.rfc-editor.org/rfc-index.html">RFCs</a>.</p><h3>Segurança</h3><p>A segurança das informações em sistemas distribuídos costumam ter um alto valor intrínseco para seus usuários. A segurança de recursos de informação tem três componentes:</p><ul><li>confidencialidade (proteção contra exposição indevida para pessoas não autorizadas)</li><li>integridade (proteção contra alteração ou dano à informação)</li><li>disponibilidade (proteção contra interferências ao acesso aos recursos)</li></ul><p>Em sistemas distribuídos, um dos desafios de segurança está no fato de que as informações são trocadas entre os diversos componentes através de uma rede, e isso significa garantir a troca segura de mensagens, ocultando seu conteúdo durante o transporte e também identificar o usuário ou componente que enviou uma requisição. Esses dois desafios costumam ser resolvidos com o uso de técnicas de criptografia desenvolvidas para esse propósito. Entretanto, existem dois desafios de segurança que ainda não foram totalmente resolvidos:</p><ul><li>negação de serviço (DoS - <em>Denial of Service</em>): um usuário interrompe um serviço por algum motivo. Pode ser alcançado bombardeando o serviço com um grande número de pedidos sem sentido. Existem medidas para se opor a isso, mas não existe uma solução geral e definitiva para o DoS</li><li>segurança de código móvel: programas ou códigos desconhecidos podem possuir efeitos de execução imprevisíveis, podendo carregar malwares</li></ul><h3>Escalabilidade</h3><p>Um sistema é descrito como escalável se permanece eficiente quando há um aumento significativo no número de recursos utilizados ou usuários conectados. Projetar um sistema distribuído escalável apresenta os seguintes desafios:</p><ul><li>controlar o custo dos recursos físicos: há um custo monetário para aquisição de hardware e software para ampliar o sistema para atender a uma nova demanda.</li><li>controlar a perda de desempenho: incluir novos componentes ou máquinas significa manter mais coordenação, e o ganho de entrega de recursos de uma nova máquina deve ser maior que o custo computacional em coordená-la.</li><li>impedir o esgotamento de recursos de software: um exemplo de falta de escalabilidade é o IPv4, que possuia 32 bits de tamanho, sendo incompatível com demandas mais modernas de acesso à internet. É difícil prever, com anos de antecedência, a demanda que será imposta sobre um sistema. Além disso, superestimar o crescimento futuro não é interessante pelo gasto extra e desnecessário de recursos.</li><li>evitar gargalos de desempenho: em geral, os pontos críticos do sistema devem ser descentralizados, para evitar um gargalo de desempenho, isto é, distribuir esses pontos de gargalo entre várias máquinas.</li></ul><h3>Tratamento de falhas</h3><p>Quando ocorrem falhas no hardware ou software, os programas podem produzir resultados incorretos, ou mesmo pararem sua execução. As falhas em um sistema distribuído costumam ser parciais, isto é, alguns componentes falham, enquanto outros continuam funcionando. Desta forma, a detecção e tratamento de falhas pode ser mais difícil. Algumas técnicas para tratar falhas incluem:</p><ul><li>utilizar somas de verificação ou assinaturas (fingerprints): é possível detectar dados danificados em uma mensagem ou arquivo através de somas de verificação</li><li>mascaramento de falhas: algumas falhas podem ser ocultadas do cliente final, ou pelo menos se tornarem menos sérias, como por exemplo a retransmissão de uma mensagem corrompida ou que não chegou. Em casos mais sérios, não é possível realizar esse mascaramento</li><li>tolerância a falhas: quando uma falha não consegue ser mascarada, o cliente pode ser projetado a tolerar essa falha. Por exemplo, quando um navegador não consegue se conectar a um servidor web, ele não faz o usuário esperar eternamente, e sim apresenta um erro que informa o usuário sobre o problema</li><li>recuperação de falhas: a recuperação envolve projetar o sistema de modo que estados anteriores dos dados possam ser recuperados ou retrocedidos</li><li>redundância: os serviços podem se tornar mais resilientes a falhas com o uso de componentes redundantes, por exemplo, ter pelo menos duas rotas diferentes entre dois roteadores, ou pelo menos dois links de internet para um servidor, ou pelo menos duas réplicas de um banco de dados, etc.</li></ul><h3>Concorrência e sincronização</h3><p>Durante o dia a dia de uso de um sistema distribuído há sempre a possibilidade de que vários clientes tentem acessar um recurso compartilhado ao mesmo tempo. É possível, por exemplo, que duas pessoas comprem ao mesmo tempo a última passagem de um vôo, pois o sistema as processou simultaneamente e considerou as duas válidas.</p><p>Uma forma de resolver esse problema é aceitar e tratar apenas um pedido de um cliente por vez. Por mais que garanta a consistência, essa limitação diminui muito o desempenho de um sistema, que poderia permitir o processamento de vários pedidos ao mesmo tempo.</p><p>Como qualquer objeto que represente um recurso compartilhado em um sistema distribuído deve ser responsável por garantir que ele opere corretamente em um ambiente concorrente, é necessário a utilização de técnicas de consistência e sincronização, como por exemplo semáforos.</p><h3>Transparência</h3><p>A transparência significa a ocultação da natureza distribuída do sistema. O usuário final ou o programador de algum aplicativo de integração consegue observar apenas o sistema como um todo, e não o conjunto de componentes independentes.</p><script async type="module">import mermaid from"https://unpkg.com/mermaid@10/dist/mermaid.esm.min.mjs";document.addEventListener("DOMContentLoaded",mermaid.initialize({loadOnSave:!0}))</script></div></body></html>